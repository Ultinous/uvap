<!DOCTYPE html><html lang=""><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>UVAP · Ultinous Video Analytics Platform</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Ultinous Video Analytics Platform"/><meta property="og:title" content="UVAP · Ultinous Video Analytics Platform"/><meta property="og:type" content="website"/><meta property="og:url" content="http://docs.ultinous.com/uvap/../../../index.html"/><meta property="og:description" content="Ultinous Video Analytics Platform"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="../../../img/face-200.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="stylesheet" href="../../../css/code-block-buttons.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="../../../js/code-block-copy-button.js"></script><script type="text/javascript" src="../../../js/code-block-download-button.js"></script><script src="../../../js/scrollSpy.js"></script><link rel="stylesheet" href="../../../css/main.css"/><script src="../../../js/codetabs.js"></script></head><body><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="../../../"><img class="logo" src="../../../img/ultinous-logo-BW-logo.png" alt="UVAP"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="../../../docs/feat/feat_overview.html" target="_self">Key Features</a></li><li class=""><a href="../../../docs/demo/demo_overview.html" target="_self">Feature Demos</a></li><li class=""><a href="../../../docs/install/uvap_install_sysreq.html" target="_self">Installation</a></li><li class=""><a href="../../../docs/dev/uvap_architect.html" target="_self">Developer Guide</a></li><li class=""><a href="../../../docs/operation/op_guide.html" target="_self">Operation Guide</a></li><li class=""><a href="../../../docs/tutorials/uvap_example_analysis.html" target="_self">Tutorials</a></li><li class=""><a href="../../../docs/help/uvap_support.html" target="_self">Help</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer documentContainer postContainer"><div class="wrapper"><div class="post"><div><a target="_blank" class="btnDownload" href="../../../_src_demo_applications/utils/uvap/graphics.py"></a><div class="static-file-code-block"><pre><code class="hljs css language-python codeBlockCopy"><span class="hljs-keyword">import</span> enum
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> List, Tuple

<span class="hljs-keyword">import</span> cv2
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np

PASS_EVENT_CHARS = {
    <span class="hljs-string">"LR"</span>: <span class="hljs-string">"&gt;"</span>,
    <span class="hljs-string">"RL"</span>: <span class="hljs-string">"&lt;"</span>
}

<span class="hljs-comment"># The original COCO skeleton type</span>
COCO_MODEL = (
    (<span class="hljs-string">"NECK"</span>, <span class="hljs-string">"RIGHT_HIP"</span>),
    (<span class="hljs-string">"RIGHT_HIP"</span>, <span class="hljs-string">"RIGHT_KNEE"</span>),
    (<span class="hljs-string">"RIGHT_KNEE"</span>, <span class="hljs-string">"RIGHT_ANKLE"</span>),
    (<span class="hljs-string">"NECK"</span>, <span class="hljs-string">"LEFT_HIP"</span>),
    (<span class="hljs-string">"LEFT_HIP"</span>, <span class="hljs-string">"LEFT_KNEE"</span>),
    (<span class="hljs-string">"LEFT_KNEE"</span>, <span class="hljs-string">"LEFT_ANKLE"</span>),
    (<span class="hljs-string">"NECK"</span>, <span class="hljs-string">"RIGHT_SHOULDER"</span>),
    (<span class="hljs-string">"RIGHT_SHOULDER"</span>, <span class="hljs-string">"RIGHT_ELBOW"</span>),
    (<span class="hljs-string">"RIGHT_ELBOW"</span>, <span class="hljs-string">"RIGHT_WRIST"</span>),
    (<span class="hljs-string">"NECK"</span>, <span class="hljs-string">"LEFT_SHOULDER"</span>),
    (<span class="hljs-string">"LEFT_SHOULDER"</span>, <span class="hljs-string">"LEFT_ELBOW"</span>),
    (<span class="hljs-string">"LEFT_ELBOW"</span>, <span class="hljs-string">"LEFT_WRIST"</span>),
    (<span class="hljs-string">"NECK"</span>, <span class="hljs-string">"NOSE"</span>),
    (<span class="hljs-string">"NOSE"</span>, <span class="hljs-string">"RIGHT_EYE"</span>),
    (<span class="hljs-string">"NOSE"</span>, <span class="hljs-string">"LEFT_EYE"</span>),
    (<span class="hljs-string">"RIGHT_EYE"</span>, <span class="hljs-string">"RIGHT_EAR"</span>),
    (<span class="hljs-string">"LEFT_EYE"</span>, <span class="hljs-string">"LEFT_EAR"</span>),
)

<span class="hljs-comment"># Skeleton with spine joint</span>
COCO_MODEL_WITH_PELVIS = (
    (<span class="hljs-string">"NECK"</span>, <span class="hljs-string">"PELVIS"</span>),
    (<span class="hljs-string">"NECK"</span>, <span class="hljs-string">"RIGHT_SHOULDER"</span>),
    (<span class="hljs-string">"NECK"</span>, <span class="hljs-string">"LEFT_SHOULDER"</span>),
    (<span class="hljs-string">"PELVIS"</span>, <span class="hljs-string">"RIGHT_HIP"</span>),
    (<span class="hljs-string">"PELVIS"</span>, <span class="hljs-string">"LEFT_HIP"</span>),
    (<span class="hljs-string">"NECK"</span>, <span class="hljs-string">"NOSE"</span>),
    (<span class="hljs-string">"NOSE"</span>, <span class="hljs-string">"RIGHT_EYE"</span>),
    (<span class="hljs-string">"NOSE"</span>, <span class="hljs-string">"LEFT_EYE"</span>),
    (<span class="hljs-string">"RIGHT_EYE"</span>, <span class="hljs-string">"RIGHT_EAR"</span>),
    (<span class="hljs-string">"LEFT_EYE"</span>, <span class="hljs-string">"LEFT_EAR"</span>),
    (<span class="hljs-string">"RIGHT_HIP"</span>, <span class="hljs-string">"RIGHT_KNEE"</span>),
    (<span class="hljs-string">"LEFT_HIP"</span>, <span class="hljs-string">"LEFT_KNEE"</span>),
    (<span class="hljs-string">"RIGHT_KNEE"</span>, <span class="hljs-string">"RIGHT_ANKLE"</span>),
    (<span class="hljs-string">"LEFT_KNEE"</span>, <span class="hljs-string">"LEFT_ANKLE"</span>),
    (<span class="hljs-string">"RIGHT_SHOULDER"</span>, <span class="hljs-string">"RIGHT_ELBOW"</span>),
    (<span class="hljs-string">"LEFT_SHOULDER"</span>, <span class="hljs-string">"LEFT_ELBOW"</span>),
    (<span class="hljs-string">"RIGHT_ELBOW"</span>, <span class="hljs-string">"RIGHT_WRIST"</span>),
    (<span class="hljs-string">"LEFT_ELBOW"</span>, <span class="hljs-string">"LEFT_WRIST"</span>),
)

<span class="hljs-comment"># Coloring for each skeleton point</span>
TYPE_TO_COLOR = {
    <span class="hljs-string">"UNKNOWN_SKELETON_POINT"</span>: (<span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>),
    <span class="hljs-string">"NOSE"</span>: (<span class="hljs-number">179</span>, <span class="hljs-number">179</span>, <span class="hljs-number">179</span>),
    <span class="hljs-string">"NECK"</span>: (<span class="hljs-number">179</span>, <span class="hljs-number">179</span>, <span class="hljs-number">179</span>),
    <span class="hljs-string">"RIGHT_HIP"</span>: (<span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-number">96</span>),
    <span class="hljs-string">"RIGHT_KNEE"</span>: (<span class="hljs-number">0</span>, <span class="hljs-number">15</span>, <span class="hljs-number">156</span>),
    <span class="hljs-string">"RIGHT_ANKLE"</span>: (<span class="hljs-number">0</span>, <span class="hljs-number">25</span>, <span class="hljs-number">255</span>),
    <span class="hljs-string">"LEFT_HIP"</span>: (<span class="hljs-number">96</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>),
    <span class="hljs-string">"LEFT_KNEE"</span>: (<span class="hljs-number">176</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>),
    <span class="hljs-string">"LEFT_ANKLE"</span>: (<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>),
    <span class="hljs-string">"RIGHT_SHOULDER"</span>: (<span class="hljs-number">96</span>, <span class="hljs-number">0</span>, <span class="hljs-number">96</span>),
    <span class="hljs-string">"RIGHT_ELBOW"</span>: (<span class="hljs-number">176</span>, <span class="hljs-number">0</span>, <span class="hljs-number">176</span>),
    <span class="hljs-string">"RIGHT_WRIST"</span>: (<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>),
    <span class="hljs-string">"LEFT_SHOULDER"</span>: (<span class="hljs-number">0</span>, <span class="hljs-number">96</span>, <span class="hljs-number">0</span>),
    <span class="hljs-string">"LEFT_ELBOW"</span>: (<span class="hljs-number">0</span>, <span class="hljs-number">176</span>, <span class="hljs-number">0</span>),
    <span class="hljs-string">"LEFT_WRIST"</span>: (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>),
    <span class="hljs-string">"RIGHT_EYE"</span>: (<span class="hljs-number">0</span>, <span class="hljs-number">156</span>, <span class="hljs-number">156</span>),
    <span class="hljs-string">"LEFT_EYE"</span>: (<span class="hljs-number">176</span>, <span class="hljs-number">176</span>, <span class="hljs-number">0</span>),
    <span class="hljs-string">"RIGHT_EAR"</span>: (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>),
    <span class="hljs-string">"LEFT_EAR"</span>: (<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>),
    <span class="hljs-string">"PELVIS"</span>: (<span class="hljs-number">0</span>, <span class="hljs-number">102</span>, <span class="hljs-number">255</span>)
}

HEAD_KEYPOINTS = (
    <span class="hljs-string">'NOSE'</span>, <span class="hljs-string">'RIGHT_EYE'</span>, <span class="hljs-string">'LEFT_EYE'</span>, <span class="hljs-string">'LEFT_EYE'</span>, <span class="hljs-string">'RIGHT_EYE'</span>
)

END_KEYPOINTS = (
    <span class="hljs-string">'LEFT_EAR'</span>, <span class="hljs-string">'RIGHT_EAR'</span>, <span class="hljs-string">'RIGHT_WRIST'</span>, <span class="hljs-string">'LEFT_WRIST'</span>, <span class="hljs-string">'RIGHT_ANKLE'</span>, <span class="hljs-string">'LEFT_ANKLE'</span>
)

ULTINOUS_LOGO = cv2.imread(<span class="hljs-string">'resources/powered_by_white.png'</span>, cv2.IMREAD_UNCHANGED)


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Position</span><span class="hljs-params">(enum.Enum)</span>:</span>
    BOTTOM_RIGHT = <span class="hljs-number">1</span>
    BOTTOM_LEFT = <span class="hljs-number">2</span>
    TOP_RIGHT = <span class="hljs-number">3</span>
    TOP_LEFT = <span class="hljs-number">4</span>


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextPosition</span><span class="hljs-params">(enum.Enum)</span>:</span>
    TOP = <span class="hljs-number">1</span>
    CENTER = <span class="hljs-number">2</span>
    BOTTOM = <span class="hljs-number">3</span>


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_generate_pelvis</span><span class="hljs-params">(points: List[dict])</span> -&gt; List[dict]:</span>
    new_points = points
    r_hip = [key_point <span class="hljs-keyword">for</span> key_point <span class="hljs-keyword">in</span> points <span class="hljs-keyword">if</span> key_point[<span class="hljs-string">'type'</span>] == <span class="hljs-string">'RIGHT_HIP'</span>]
    l_hip = [key_point <span class="hljs-keyword">for</span> key_point <span class="hljs-keyword">in</span> points <span class="hljs-keyword">if</span> key_point[<span class="hljs-string">'type'</span>] == <span class="hljs-string">'LEFT_HIP'</span>]

    <span class="hljs-keyword">if</span> len(r_hip) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> len(l_hip) &gt; <span class="hljs-number">0</span>:
        pelvis_x = (r_hip[<span class="hljs-number">0</span>][<span class="hljs-string">'x'</span>] + l_hip[<span class="hljs-number">0</span>][<span class="hljs-string">'x'</span>]) / <span class="hljs-number">2</span>
        pelvis_y = (r_hip[<span class="hljs-number">0</span>][<span class="hljs-string">'y'</span>] + l_hip[<span class="hljs-number">0</span>][<span class="hljs-string">'y'</span>]) / <span class="hljs-number">2</span>
    <span class="hljs-keyword">elif</span> len(l_hip) &gt; <span class="hljs-number">0</span>:
        pelvis_x = l_hip[<span class="hljs-number">0</span>][<span class="hljs-string">'x'</span>]
        pelvis_y = l_hip[<span class="hljs-number">0</span>][<span class="hljs-string">'y'</span>]
    <span class="hljs-keyword">elif</span> len(r_hip) &gt; <span class="hljs-number">0</span>:
        pelvis_x = r_hip[<span class="hljs-number">0</span>][<span class="hljs-string">'x'</span>]
        pelvis_y = r_hip[<span class="hljs-number">0</span>][<span class="hljs-string">'y'</span>]
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> points

    d = {
        <span class="hljs-string">'x'</span>: pelvis_x,
        <span class="hljs-string">'y'</span>: pelvis_y,
        <span class="hljs-string">'type'</span>: <span class="hljs-string">'PELVIS'</span>,
        <span class="hljs-string">'confidence'</span>: <span class="hljs-number">0.9</span>
    }
    new_points.append(dict(d))
    <span class="hljs-keyword">return</span> new_points


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_draw_skeleton</span><span class="hljs-params">(
        canvas: np.array,
        points: List[dict],
        skip_unknown=True,
        model=COCO_MODEL_WITH_PELVIS,
        color_palette=TYPE_TO_COLOR,
        point_size=<span class="hljs-number">5</span>,
        joint_width=<span class="hljs-number">3</span>,
        scaling=<span class="hljs-number">1.0</span>
)</span> -&gt; np.array:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">skeleton_point_to_cv</span><span class="hljs-params">(pt, scaling)</span>:</span>
        <span class="hljs-keyword">return</span> (int(round(pt[<span class="hljs-string">"x"</span>] * scaling)), int(round(pt[<span class="hljs-string">"y"</span>] * scaling)))

    point_size = int(point_size * scaling)
    joint_width = int(joint_width * scaling)
    points = _generate_pelvis(points)
    <span class="hljs-comment"># draw joints</span>
    <span class="hljs-keyword">for</span> edge <span class="hljs-keyword">in</span> model:
        current_joint_width = joint_width
        u = edge[<span class="hljs-number">0</span>]
        v = edge[<span class="hljs-number">1</span>]
        u_list = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> points <span class="hljs-keyword">if</span> x[<span class="hljs-string">"type"</span>] == u]
        v_list = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> points <span class="hljs-keyword">if</span> x[<span class="hljs-string">"type"</span>] == v]
        <span class="hljs-keyword">if</span> u_list <span class="hljs-keyword">and</span> v_list:
            <span class="hljs-keyword">if</span> u_list[<span class="hljs-number">0</span>][<span class="hljs-string">'type'</span>] <span class="hljs-keyword">in</span> [] <span class="hljs-keyword">or</span> v_list[<span class="hljs-number">0</span>][<span class="hljs-string">'type'</span>] <span class="hljs-keyword">in</span> HEAD_KEYPOINTS:
                current_joint_width = int(np.ceil(current_joint_width * <span class="hljs-number">0.6</span>))
                current_joint_width = int(np.ceil(current_joint_width * <span class="hljs-number">0.6</span>))
            cv2.line(
                canvas,
                skeleton_point_to_cv(u_list[<span class="hljs-number">0</span>], scaling), skeleton_point_to_cv(v_list[<span class="hljs-number">0</span>], scaling),
                color_palette[v],
                current_joint_width,
                cv2.LINE_AA
            )

    <span class="hljs-comment"># draw keypoints</span>
    <span class="hljs-keyword">for</span> pt <span class="hljs-keyword">in</span> points:
        current_point_size = point_size
        <span class="hljs-keyword">if</span> pt[<span class="hljs-string">"type"</span>] == <span class="hljs-string">"UNKNOWN_SKELETON_POINT"</span> <span class="hljs-keyword">and</span> skip_unknown:
            <span class="hljs-keyword">continue</span>
        <span class="hljs-keyword">if</span> pt[<span class="hljs-string">'type'</span>] <span class="hljs-keyword">in</span> HEAD_KEYPOINTS:
            current_point_size = int(<span class="hljs-number">0.6</span> * current_point_size)

        <span class="hljs-keyword">if</span> pt[<span class="hljs-string">'type'</span>] <span class="hljs-keyword">in</span> END_KEYPOINTS:
            x, y = skeleton_point_to_cv(pt, scaling)
            pt1 = (x - current_point_size, y - current_point_size)
            pt2 = (x + current_point_size, y + current_point_size)
            cv2.rectangle(canvas, pt1, pt2, color=color_palette[pt[<span class="hljs-string">"type"</span>]], thickness=cv2.FILLED, lineType=cv2.LINE_AA)
        <span class="hljs-keyword">elif</span> pt[<span class="hljs-string">'type'</span>] <span class="hljs-keyword">in</span> (<span class="hljs-string">'PELVIS'</span>, <span class="hljs-string">'NECK'</span>):
            <span class="hljs-keyword">continue</span>
        <span class="hljs-keyword">else</span>:
            cv2.circle(
                canvas,
                skeleton_point_to_cv(pt, scaling),
                current_point_size,
                color_palette[pt[<span class="hljs-string">"type"</span>]],
                cv2.FILLED,
                cv2.LINE_AA
            )
    <span class="hljs-keyword">return</span> canvas


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_get_bounding_box_thickness</span><span class="hljs-params">(bounding_box: dict, scale=<span class="hljs-number">1.0</span>)</span> -&gt; float:</span>
    smaller_side = min(bounding_box[<span class="hljs-string">'width'</span>], bounding_box[<span class="hljs-string">'height'</span>]) * scale
    <span class="hljs-keyword">return</span> (smaller_side * <span class="hljs-number">0.5</span>) / <span class="hljs-number">48</span>


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_draw_bounding_box</span><span class="hljs-params">(
        canvas: np.array,
        bounding_box: dict,
        color: tuple,
        scaling=<span class="hljs-number">1.0</span>,
        f_border=<span class="hljs-number">0.0</span>
)</span> -&gt; np.array:</span>
    base_thickness = _get_bounding_box_thickness(bounding_box, scaling)
    thick = max(<span class="hljs-number">1</span>, int(round(base_thickness * <span class="hljs-number">6</span>)))
    thin = max(<span class="hljs-number">1</span>, int(round(base_thickness)))

    border = int(np.ceil(base_thickness * f_border))

    circle_radius = max(<span class="hljs-number">1</span>, int(<span class="hljs-number">1.5</span> * thick))
    circle_center = max(<span class="hljs-number">1</span>, <span class="hljs-number">2</span> * thick)

    x0 = int(round(bounding_box[<span class="hljs-string">'x'</span>] * scaling))
    y0 = int(round(bounding_box[<span class="hljs-string">'y'</span>] * scaling))
    x1 = x0 + int(round(bounding_box[<span class="hljs-string">'width'</span>] * scaling)) - <span class="hljs-number">1</span>
    y1 = y0 + int(round(bounding_box[<span class="hljs-string">'height'</span>] * scaling)) - <span class="hljs-number">1</span>

    <span class="hljs-comment"># Top and bottom thin boundaries</span>
    cv2.rectangle(
        img=canvas, color=color, thickness=cv2.FILLED, lineType=cv2.LINE_AA,
        pt1=(x0 + <span class="hljs-number">2</span> * circle_center, y0 - border),
        pt2=(x1 - <span class="hljs-number">2</span> * circle_center, y0 + thin + border)
    )
    cv2.rectangle(
        img=canvas, color=color, thickness=cv2.FILLED, lineType=cv2.LINE_AA,
        pt1=(x0 + <span class="hljs-number">2</span> * circle_center, y1 - thin - border),
        pt2=(x1 - <span class="hljs-number">2</span> * circle_center, y1 + border)
    )

    <span class="hljs-comment"># Thin side boundaries</span>
    cv2.rectangle(
        img=canvas, color=color, thickness=cv2.FILLED, lineType=cv2.LINE_AA,
        pt1=(x0 - border, y0 + <span class="hljs-number">2</span> * circle_center),
        pt2=(x0 + thin + border, y1 - <span class="hljs-number">2</span> * circle_center)
    )
    cv2.rectangle(
        img=canvas, color=color, thickness=cv2.FILLED, lineType=cv2.LINE_AA,
        pt1=(x1 - thin - border, y0 + <span class="hljs-number">2</span> * circle_center),
        pt2=(x1 + border, y1 - <span class="hljs-number">2</span> * circle_center)
    )

    <span class="hljs-comment"># Top-left thick boundaries</span>
    cv2.rectangle(
        img=canvas, color=color, thickness=cv2.FILLED, lineType=cv2.LINE_AA,
        pt1=(x0 + circle_center, y0 - border),
        pt2=(x0 + <span class="hljs-number">2</span> * circle_center + border, y0 + thick + border),
    )
    cv2.rectangle(
        img=canvas, color=color, thickness=cv2.FILLED, lineType=cv2.LINE_AA,
        pt1=(x0 - border, y0 + circle_center),
        pt2=(x0 + thick + border, y0 + <span class="hljs-number">2</span> * circle_center + border)
    )

    <span class="hljs-comment"># Top-right thick boundaries</span>
    cv2.rectangle(
        img=canvas, color=color, thickness=cv2.FILLED, lineType=cv2.LINE_AA,
        pt1=(x1 - <span class="hljs-number">2</span> * circle_center - border, y0 - border),
        pt2=(x1 - circle_center, y0 + thick + border)
    )
    cv2.rectangle(
        img=canvas, color=color, thickness=cv2.FILLED, lineType=cv2.LINE_AA,
        pt1=(x1 - thick - border, y0 + circle_center),
        pt2=(x1 + border, y0 + <span class="hljs-number">2</span> * circle_center + border),
    )

    <span class="hljs-comment"># Bottom-left thick boundaries</span>
    cv2.rectangle(
        img=canvas, color=color, thickness=cv2.FILLED, lineType=cv2.LINE_AA,
        pt1=(x0 + circle_center, y1 - thick - border),
        pt2=(x0 + <span class="hljs-number">2</span> * circle_center + border, y1 + border)
    )
    cv2.rectangle(
        img=canvas, color=color, thickness=cv2.FILLED, lineType=cv2.LINE_AA,
        pt1=(x0 - border, y1 - <span class="hljs-number">2</span> * circle_center - border),
        pt2=(x0 + thick + border, y1 - circle_center)
    )

    <span class="hljs-comment"># Bottom-right thick boundaries</span>
    cv2.rectangle(
        img=canvas, color=color, thickness=cv2.FILLED, lineType=cv2.LINE_AA,
        pt1=(x1 - <span class="hljs-number">2</span> * circle_center - border, y1 - thick - border),
        pt2=(x1 - circle_center, y1 + border)
    )
    cv2.rectangle(
        img=canvas, color=color, thickness=cv2.FILLED, lineType=cv2.LINE_AA,
        pt1=(x1 - thick - border, y1 - <span class="hljs-number">2</span> * circle_center - border),
        pt2=(x1 + border, y1 - circle_center)
    )

    <span class="hljs-comment"># Rounded corners TOP to Bottom, Left to Right</span>
    cv2.ellipse(
        img=canvas,
        center=(x0 + circle_center, y0 + circle_center),
        axes=(circle_radius, circle_radius),
        angle=<span class="hljs-number">180.0</span>, startAngle=<span class="hljs-number">0.0</span>, endAngle=<span class="hljs-number">90.0</span>,
        color=color, thickness=thick + <span class="hljs-number">2</span> * border, lineType=cv2.LINE_AA)
    cv2.ellipse(
        img=canvas,
        center=(x1 - circle_center, y0 + circle_center),
        axes=(circle_radius, circle_radius),
        angle=<span class="hljs-number">270.0</span>, startAngle=<span class="hljs-number">0.0</span>, endAngle=<span class="hljs-number">90.0</span>,
        color=color, thickness=thick + <span class="hljs-number">2</span> * border, lineType=cv2.LINE_AA)
    cv2.ellipse(
        img=canvas,
        center=(x1 - circle_center, y1 - circle_center),
        axes=(circle_radius, circle_radius),
        angle=<span class="hljs-number">0.0</span>, startAngle=<span class="hljs-number">0.0</span>, endAngle=<span class="hljs-number">90.0</span>,
        color=color, thickness=thick + <span class="hljs-number">2</span> * border, lineType=cv2.LINE_AA)
    cv2.ellipse(
        img=canvas,
        center=(x0 + circle_center, y1 - circle_center),
        axes=(circle_radius, circle_radius),
        angle=<span class="hljs-number">90.0</span>, startAngle=<span class="hljs-number">0.0</span>, endAngle=<span class="hljs-number">90.0</span>,
        color=color, thickness=thick + <span class="hljs-number">2</span> * border, lineType=cv2.LINE_AA)

    <span class="hljs-keyword">return</span> canvas


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_draw_3d_lines</span><span class="hljs-params">(canvas, center, directions)</span>:</span>
    y_dir = (center[<span class="hljs-number">0</span>] + directions[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], center[<span class="hljs-number">1</span>] + directions[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>])
    x_dir = (center[<span class="hljs-number">0</span>] + directions[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], center[<span class="hljs-number">1</span>] + directions[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])
    z_dir = (center[<span class="hljs-number">0</span>] + directions[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>], center[<span class="hljs-number">1</span>] + directions[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>])
    canvas = cv2.line(canvas, center, y_dir, (<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>, cv2.LINE_AA)
    canvas = cv2.line(canvas, center, x_dir, (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>, cv2.LINE_AA)
    canvas = cv2.line(canvas, center, z_dir, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">2</span>, cv2.LINE_AA)
    <span class="hljs-keyword">return</span> canvas


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_rotation_mtx</span><span class="hljs-params">(rot_vec)</span>:</span>
    a, b, g = (rot_vec * np.pi / <span class="hljs-number">180.0</span>)

    <span class="hljs-keyword">return</span> np.array(
        [
            [np.cos(a) * np.cos(b), np.cos(a) * np.sin(b) * np.sin(g) - np.sin(a) * np.cos(g),
             np.cos(a) * np.sin(b) * np.cos(g) + np.sin(a) * np.sin(g)],
            [np.sin(a) * np.cos(b), np.sin(a) * np.sin(b) * np.sin(g) + np.cos(a) * np.cos(g),
             np.sin(a) * np.sin(b) * np.cos(g) - np.cos(a) * np.sin(g)],
            [-np.sin(b), np.cos(b) * np.sin(g), np.cos(b) * np.cos(g)]
        ]
    )


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw_skeleton_with_background</span><span class="hljs-params">(
        canvas: np.array,
        points: List[dict],
        skip_unknown=True,
        model=COCO_MODEL_WITH_PELVIS,
        color_palette=TYPE_TO_COLOR,
        point_size=<span class="hljs-number">5</span>,
        joint_width=<span class="hljs-number">3</span>,
        draw_background=True,
        background_color=<span class="hljs-params">(<span class="hljs-number">195</span>, <span class="hljs-number">195</span>, <span class="hljs-number">195</span>)</span>,
        scaling=<span class="hljs-number">1.0</span>
)</span> -&gt; np.array:</span>
    <span class="hljs-string">"""
    Draw skeleton to a canvas with an additional background.
    :param canvas: the target image
    :param points: points of the skeleton
    :param skip_unknown: to draw unknown skeleton points or not
    :param model: the skeleton type (for example with spine or original COCO type)
    :param color_palette: coloring of the key points and joints
    :param point_size: skeleton key point size in pixels
    :param joint_width: skeleton joint size in pixels
    :param draw_background: background drawing switch
    :param background_color: coloring behind the skeleton
    :return: image with the skeleton
    """</span>
    back_color = {k: background_color <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> color_palette}
    <span class="hljs-keyword">if</span> draw_background:
        canvas = _draw_skeleton(
            canvas, points,
            skip_unknown=skip_unknown,
            model=model,
            color_palette=back_color,
            point_size=point_size + <span class="hljs-number">1</span>,
            joint_width=joint_width + <span class="hljs-number">3</span>,
            scaling=scaling
        )
    canvas = _draw_skeleton(
        canvas, points,
        skip_unknown=skip_unknown,
        model=model,
        point_size=point_size,
        joint_width=joint_width,
        scaling=scaling
    )
    <span class="hljs-keyword">return</span> canvas


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw_nice_bounding_box</span><span class="hljs-params">(
        canvas: np.array,
        bounding_box: dict,
        color: tuple,
        scaling=<span class="hljs-number">1.0</span>,
        f_border=<span class="hljs-number">0.0</span>,
        shadow=True
)</span> -&gt; np.array:</span>
    <span class="hljs-string">"""
    Draw bounding box with nice dynamically changing edges and a shadow to an image.
    :param canvas: target image
    :param bounding_box: coordinates with width and height
    :param color: BGR color of the bounding box
    :param scaling: scaling factor, default for 1080p
    :param f_border: base thickness of the bounding box
    :param shadow: to visualize bounding box shadow or not
    :return: image with bounding box
    """</span>
    <span class="hljs-keyword">if</span> shadow:
        canvas = _draw_bounding_box(canvas, bounding_box, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), scaling, <span class="hljs-number">0.5</span>)
    canvas = _draw_bounding_box(canvas, bounding_box, color, scaling, f_border)
    <span class="hljs-keyword">return</span> canvas


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw_nice_text</span><span class="hljs-params">(
        canvas: np.array,
        text: str,
        bounding_box: dict,
        color: tuple,
        scale=<span class="hljs-number">1.0</span>,
        shadow=True
)</span> -&gt; np.array:</span>
    <span class="hljs-string">"""
    Draw text with dynamically changing size and shadow to an image top of a bounding box.
    :param canvas: target image
    :param text: drawable text
    :param bounding_box: bounding box for text location and size computation
    :param color: BRG color of the text
    :param scale: scaling factor, default for 1080p
    :param shadow: to visualize text shadow or not
    :return: image with nice text
    """</span>
    x = bounding_box[<span class="hljs-string">'x'</span>]
    y = bounding_box[<span class="hljs-string">'y'</span>]
    w = bounding_box[<span class="hljs-string">'width'</span>]

    font_size = w * scale / <span class="hljs-number">60</span>
    font_face = cv2.FONT_HERSHEY_COMPLEX_SMALL
    font_thicness = <span class="hljs-number">1</span>
    (txt_size, _) = cv2.getTextSize(text, font_face, font_size, font_thicness)

    pt1 = x * scale + w * scale / <span class="hljs-number">2</span> - txt_size[<span class="hljs-number">0</span>] / <span class="hljs-number">2</span>
    pt2 = y * scale - int(<span class="hljs-number">0.3</span> * txt_size[<span class="hljs-number">1</span>])

    <span class="hljs-keyword">if</span> shadow:
        cv2.putText(canvas, text, (int(pt1), int(pt2)), font_face, font_size, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), font_thicness + <span class="hljs-number">1</span>,
                    lineType=cv2.LINE_AA)
    cv2.putText(canvas, text, (int(pt1), int(pt2)), font_face, font_size, color, font_thicness, lineType=cv2.LINE_AA)

    <span class="hljs-keyword">return</span> canvas


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw_nice_text_under_bb</span><span class="hljs-params">(
        canvas: np.array,
        text: str,
        bounding_box: dict,
        color: tuple,
        scale=<span class="hljs-number">1.0</span>,
        shadow=True,
        line=<span class="hljs-number">1</span>
)</span> -&gt; np.array:</span>
    <span class="hljs-string">"""
    Draw text with dynamically changing size and shadow to an image bottom of a bounding box.
    :param canvas: target image
    :param text: drawable text
    :param bounding_box: bounding box for text location and size computation
    :param color: BRG color of the text
    :param scale: scaling factor, default for 1080p
    :param shadow: to visualize text shadow or not
    :param line: line number in which to write the message under the bounding box
    :return: image with nice text
    """</span>
    x = bounding_box[<span class="hljs-string">'x'</span>]
    y = bounding_box[<span class="hljs-string">'y'</span>]
    w = bounding_box[<span class="hljs-string">'width'</span>]
    h = bounding_box[<span class="hljs-string">'height'</span>]

    font_size = w * scale / <span class="hljs-number">60</span>
    font_face = cv2.FONT_HERSHEY_COMPLEX_SMALL
    font_thicness = <span class="hljs-number">1</span>
    (txt_size, _) = cv2.getTextSize(text, font_face, font_size, font_thicness)

    pt1 = x * scale + w * scale / <span class="hljs-number">2</span> - txt_size[<span class="hljs-number">0</span>] / <span class="hljs-number">2</span>
    pt2 = (y + h) * scale + int(txt_size[<span class="hljs-number">1</span>])*line

    <span class="hljs-keyword">if</span> shadow:
        cv2.putText(canvas, text, (int(pt1), int(pt2)), font_face, font_size, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), font_thicness + <span class="hljs-number">1</span>,
                    lineType=cv2.LINE_AA)
    cv2.putText(canvas, text, (int(pt1), int(pt2)), font_face, font_size, color, font_thicness, lineType=cv2.LINE_AA)

    <span class="hljs-keyword">return</span> canvas


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw_overlay</span><span class="hljs-params">(
        canvas: np.array,
        overlay: np.array,
        position: Position,
        scale=None,
        margin=<span class="hljs-number">20</span>
)</span> -&gt; np.array:</span>
    <span class="hljs-string">"""
    Draw images with alpha channel to the selected corner of the image.
    :param canvas: target image
    :param overlay: BGRA image
    :param position: an enum representing the corners
    :param scale: scale factor for the overlay image
    :param margin: margin around the overlay image
    :return: input image with the overlay on it
    """</span>
    <span class="hljs-keyword">if</span> scale:
        overlay = cv2.resize(overlay, <span class="hljs-literal">None</span>, fx=scale, fy=scale)

    b, g, r, alpha = cv2.split(overlay)
    overlay = cv2.merge((b, g, r))
    h, w, _ = overlay.shape
    y, x, _ = canvas.shape

    <span class="hljs-keyword">if</span> position == Position.BOTTOM_RIGHT:
        y = y - h - margin
        x = x - w - margin
    <span class="hljs-keyword">elif</span> position == Position.BOTTOM_LEFT:
        y = y - h - margin
        x = margin
    <span class="hljs-keyword">elif</span> position == Position.TOP_RIGHT:
        y = margin
        x = x - w - margin
    <span class="hljs-keyword">elif</span> position == Position.TOP_LEFT:
        y = margin
        x = margin

    roi = canvas[y:y + h, x:x + w]

    alpha = np.transpose([alpha] * <span class="hljs-number">3</span>, (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>)) / <span class="hljs-number">255.0</span>

    alpha_roi = roi - alpha * roi
    alpha_overlay = alpha * overlay

    canvas[y:y + h, x:x + w] = cv2.add(alpha_roi, alpha_overlay)

    <span class="hljs-keyword">return</span> canvas


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw_ultinous_logo</span><span class="hljs-params">(
        canvas: np.array,
        scale=<span class="hljs-number">1.0</span>
)</span>:</span>
    <span class="hljs-keyword">return</span> draw_overlay(
        canvas=canvas,
        overlay=ULTINOUS_LOGO,
        position=Position.BOTTOM_RIGHT,
        scale=scale
    )


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw_head_pose</span><span class="hljs-params">(
        canvas: np.array,
        pose: dict,
        bounding_box: dict,
        scaling=<span class="hljs-number">1.0</span>
)</span> -&gt; np.array:</span>
    <span class="hljs-string">"""
    Draw 3D visualized head pose on the input image.
    :param canvas: target image
    :param pose: (roll, pitch, yaw) values for the 3D lines
    :param bounding_box: bounding box for localization
    :param scaling: scaling factor, default 1080p
    :return: image with head pose
    """</span>
    x = bounding_box[<span class="hljs-string">'x'</span>]
    y = bounding_box[<span class="hljs-string">'y'</span>]
    width = bounding_box[<span class="hljs-string">'width'</span>]
    height = bounding_box[<span class="hljs-string">'height'</span>]

    axis_length = max(width * scaling, height * scaling) / <span class="hljs-number">2.5</span>

    center = (int((x + width // <span class="hljs-number">2</span>) * scaling), int((y + height // <span class="hljs-number">2</span>) * scaling))

    pose = np.array([-pose[<span class="hljs-string">'roll'</span>], -pose[<span class="hljs-string">'yaw'</span>], -pose[<span class="hljs-string">'pitch'</span>]])
    rotmat = _rotation_mtx(pose)

    a11 = rotmat[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]
    a12 = rotmat[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]
    a13 = rotmat[<span class="hljs-number">2</span>, <span class="hljs-number">0</span>]
    a21 = rotmat[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]
    a22 = rotmat[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]
    a23 = rotmat[<span class="hljs-number">2</span>, <span class="hljs-number">1</span>]

    imgpnts = [
        (int(a11 * axis_length), int(-a21 * axis_length)),
        (int(a12 * axis_length), int(-a22 * axis_length)),
        (int(a13 * axis_length), int(-a23 * axis_length))
    ]
    <span class="hljs-keyword">return</span> _draw_3d_lines(canvas, center, imgpnts)


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw_polyline</span><span class="hljs-params">(
        canvas: np.array,
        points: List[Tuple[int, int]],
        color: Tuple[int, int, int],
        thickness: int = <span class="hljs-number">3</span>,
        is_closed: bool = False,
        scaling=<span class="hljs-number">1.0</span>
)</span> -&gt; np.array:</span>
    <span class="hljs-string">"""
    Draw a polyline on the input image
    :param canvas: target image
    :param points: Points of the polylinye
    :param color: BGR color of the line
    :param thickness: thickness of the line.
    :param is_closed: If true, the line will be closed.
    :param scaling: scaling factor, default 1080p
    :return: image with polyline
    """</span>
    <span class="hljs-comment">#</span>
    pts = []
    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> points:
        pts.append((p[<span class="hljs-number">0</span>]*scaling, p[<span class="hljs-number">1</span>]*scaling))

    <span class="hljs-keyword">return</span> cv2.polylines(
        img=canvas,
        pts=[np.array(pts, np.int32)],
        isClosed=is_closed,
        color=color,
        thickness=thickness
    )

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw_simple_text</span><span class="hljs-params">(
        canvas: np.array,
        text: str,
        color: tuple,
        position=TextPosition.CENTER,
        thickness=<span class="hljs-number">1</span>,
        margin=<span class="hljs-number">40</span>,
        font_scale=<span class="hljs-number">1</span>,
        shadow=True
)</span> -&gt; np.array:</span>
    <span class="hljs-string">"""
    Draw text with line breaks with dynamically changing size and shadow to an image.
    :param canvas: target image
    :param text: drawable text. Use line breaks (\n) for displaying in multiple lines.
    :param color: BRG color of the text
    :param position: position of the text
    :param thickness: thickness of the font line in px
    :param margin: vertical offset of multi-lined text
    :param font_scale: font scale factor that is multiplied by the font-specific base size.
    :param shadow: to visualize text shadow or not
    :return: image with text
    """</span>
    font_face = cv2.FONT_HERSHEY_COMPLEX_SMALL
    y0 = <span class="hljs-number">10</span>
    margin = margin * font_scale

    <span class="hljs-keyword">if</span> position == TextPosition.TOP:
        y0 = margin
    <span class="hljs-keyword">if</span> position == TextPosition.CENTER:
        dimensions = (canvas.shape[<span class="hljs-number">0</span>], canvas.shape[<span class="hljs-number">1</span>])
        y0 = int(dimensions[<span class="hljs-number">0</span>] / <span class="hljs-number">2</span>)
    <span class="hljs-keyword">if</span> position == TextPosition.BOTTOM:
        line_num = text.count(<span class="hljs-string">'\n'</span>)
        y0 = canvas.shape[<span class="hljs-number">0</span>] - ((line_num + <span class="hljs-number">1</span>) * margin)

    <span class="hljs-keyword">for</span> i, line <span class="hljs-keyword">in</span> enumerate(text.split(<span class="hljs-string">'\n'</span>)):
        y = y0 + i * margin
        <span class="hljs-keyword">if</span> shadow:
            cv2.putText(
                canvas,
                line,
                (<span class="hljs-number">10</span>, y),
                font_face,
                font_scale,
                (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>),
                thickness + <span class="hljs-number">1</span>,
                lineType=cv2.LINE_AA
            )
        cv2.putText(
            canvas,
            line,
            (<span class="hljs-number">10</span>, y),
            font_face,
            font_scale,
            color,
            thickness,
            lineType=cv2.LINE_AA
        )

    <span class="hljs-keyword">return</span> canvas


</code></pre>
</div></div></div></div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="../../../" class="nav-home"></a><div class="help"><h5>Help</h5><a href="docs/assets/UVAP_License_Terms.pdf">UVAP License Terms</a><a href="../../../docs/help/uvap_gloss.html">Glossary</a><a href="../../../docs/help/uvap_notations.html">Typographic Conventions</a><a href="../../../docs/help/uvap_tm.html">Trademark Information</a><a href="../../../docs/help/uvap_support.html">Support</a></div><div class="nav"><h5>Navigation</h5><a href="../../../docs/feat/feat_overview.html">Key Features</a><a href="../../../docs/demo/demo_overview.html">Feature Demos</a><a href="../../../docs/install/uvap_install_sysreq.html">Installation</a><a href="../../../docs/dev/uvap_architect.html">Developer Guide</a><a href="../../../docs/tutorials/uvap_example_analysis.html">Tutorials</a><a href="../../../help.html">Help</a></div><div class="comm"><h5>Community</h5><a href="https://github.com/Ultinous/uvap" target="_blank">GitHub</a><a href="https://www.facebook.com/ultinousltd/" target="_blank">Facebook</a><a href="https://www.linkedin.com/company/6380970/" target="_blank">LinkedIn</a><a href="https://twitter.com/ultinousltd" target="_blank">Twitter</a><a href="https://www.youtube.com/channel/UCeQmAy_RLLhgcTxSCFljBDA" target="_blank">YouTube</a></div></section><a href="https://www.ultinous.com" target="_blank" rel="noreferrer noopener" class="fbOpenSource"><img src="../../../img/Ultinous-logo_white_web.png" alt="Ultinous"/></a><section class="copyright">Copyright © 2019-2020 Ultinous</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '537f90d4167048c6fde59df438687767',
                indexName: 'uvap',
                inputSelector: '#search_input_react'
              });
            </script></body></html>